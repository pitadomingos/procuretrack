module.exports = {

"[project]/.next-internal/server/app/api/tags/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@opentelemetry/api", () => require("@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/timers [external] (timers, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/string_decoder [external] (string_decoder, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[project]/backend/db.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getDbPool": (()=>getDbPool)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/promise.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)");
;
;
;
;
// Configure dotenv to load the .env file from the backend directory
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dotenv$2f$lib$2f$main$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].config({
    path: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(process.cwd(), 'backend', '.env')
});
let pool = null;
async function getDbPool() {
    if (pool) {
        return pool;
    }
    // --- Debugging Environment ---
    console.log('[DB_INIT] Current working directory:', process.cwd());
    console.log('[DB_INIT] Checking for environment variables...');
    try {
        // Check for essential DB environment variables
        const essentialEnvVars = [
            'DB_HOST',
            'DB_USER',
            'DB_PASSWORD',
            'DB_NAME'
        ];
        const missingEnvVars = [];
        for (const v of essentialEnvVars){
            if (!process.env[v]) {
                missingEnvVars.push(v);
            } else {
                // Avoid logging password in production
                if (v !== 'DB_PASSWORD') {
                    console.log(`[DB_INIT] Found ENV VAR: ${v} = ${process.env[v]}`);
                } else {
                    console.log(`[DB_INIT] Found ENV VAR: DB_PASSWORD = (hidden)`);
                }
            }
        }
        if (missingEnvVars.length > 0) {
            const errorMsg = `Database configuration is incomplete. Missing variables: ${missingEnvVars.join(', ')}. Please define these in your root .env file.`;
            console.error(`[DB_INIT_ERROR] ${errorMsg}`);
            throw new Error(errorMsg);
        }
        // --- SSL Certificate Handling ---
        const caCertPathOrContent = process.env.DB_SSL_CA;
        let caCertContent;
        if (caCertPathOrContent) {
            const potentialPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(process.cwd(), caCertPathOrContent);
            if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(potentialPath) && __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].statSync(potentialPath).isFile()) {
                console.log(`DB_INIT_INFO: DB_SSL_CA points to a file. Reading certificate from "${potentialPath}".`);
                caCertContent = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(potentialPath, 'utf8');
            } else {
                console.log("DB_INIT_INFO: DB_SSL_CA does not appear to be a file path. Using its content directly for SSL connection.");
                caCertContent = caCertPathOrContent;
            }
        } else {
            console.warn(`DB_WARN: The DB_SSL_CA environment variable is not set. Connecting with SSL using system default CAs. If connection fails, please provide the path to your 'ca.pem' file in the DB_SSL_CA variable in your .env file.`);
        }
        const sslConfig = {
            rejectUnauthorized: true,
            ca: caCertContent || undefined
        };
        // --- Connection Pool Creation ---
        console.log("DB_INIT_INFO: Creating database connection pool for the first time.");
        const newPool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool({
            host: process.env.DB_HOST,
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME,
            port: process.env.DB_PORT ? parseInt(process.env.DB_PORT, 10) : 3306,
            ssl: sslConfig,
            waitForConnections: true,
            connectionLimit: 10,
            queueLimit: 0
        });
        try {
            // Test the connection before assigning it to the singleton
            const connection = await newPool.getConnection();
            console.log("DB_INIT_SUCCESS: Database connection pool created and verified successfully.");
            connection.release();
        } catch (testError) {
            console.error("CRITICAL_DB_INIT_ERROR: Failed to get a connection from the pool after creation.", testError);
            // Destroy the pool if the initial connection test fails
            newPool.end();
            throw testError; // Re-throw to be caught by the main catch block
        }
        pool = newPool;
        return pool;
    } catch (error) {
        console.error(`CRITICAL_DB_INIT_ERROR: Failed to create and verify database connection pool. Error: ${error.message}`);
        // Re-throw the error to be caught by the calling API route
        throw error;
    }
}
;
}}),
"[project]/src/app/api/tags/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET),
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/backend/db.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$parser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-parser/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
;
;
;
;
const tagStatuses = [
    'Active',
    'Inactive',
    'Under Maintenance',
    'Sold',
    'Decommissioned'
];
async function GET() {
    try {
        const pool = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDbPool"])();
        const query = `
      SELECT 
        t.id, t.tagNumber, t.registration, t.make, t.model, 
        t.tankCapacity, t.year, t.chassisNo, t.type, t.siteId,
        t.status, 
        t.createdAt, t.updatedAt, 
        s.siteCode AS siteName 
      FROM Tag t
      LEFT JOIN Site s ON t.siteId = s.id
      ORDER BY t.tagNumber ASC;
    `;
        const [rows] = await pool.execute(query);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(rows);
    } catch (error) {
        console.error('Error fetching tags:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to fetch tags',
            details: error.message
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    const contentType = request.headers.get('content-type');
    const pool = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDbPool"])();
    if (contentType && contentType.includes('multipart/form-data')) {
        console.log('[API_INFO] /api/tags POST: Received multipart/form-data request for CSV upload.');
        let connection;
        try {
            const formData = await request.formData();
            const file = formData.get('file');
            if (!file) {
                console.error('[API_ERROR] /api/tags POST CSV: No file found in formData.');
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'No file uploaded'
                }, {
                    status: 400
                });
            }
            console.log(`[API_INFO] /api/tags POST CSV: Received file: ${file.name}, size: ${file.size}, type: ${file.type}`);
            const fileBuffer = Buffer.from(await file.arrayBuffer());
            const results = [];
            const stream = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"].from(fileBuffer);
            let firstRecordLogged = false;
            console.log('[API_INFO] /api/tags POST CSV: Starting CSV parsing...');
            await new Promise((resolve, reject)=>{
                stream.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$parser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                    mapHeaders: ({ header })=>header.trim().toLowerCase() // Trim and lowercase headers for consistency
                })).on('headers', (headers)=>{
                    console.log('[API_INFO] /api/tags POST CSV: Detected CSV Headers (lowercased):', headers);
                }).on('data', (data)=>{
                    if (!firstRecordLogged) {
                        console.log('[API_DEBUG] /api/tags POST CSV: First parsed data record from CSV:', data);
                        firstRecordLogged = true;
                    }
                    results.push(data);
                }).on('end', ()=>{
                    console.log(`[API_INFO] /api/tags POST CSV: CSV parsing finished. ${results.length} records found.`);
                    resolve();
                }).on('error', (parseError)=>{
                    console.error('[API_ERROR] /api/tags POST CSV: Error during CSV parsing:', parseError);
                    reject(parseError);
                });
            });
            if (results.length === 0) {
                console.warn('[API_WARN] /api/tags POST CSV: CSV file is empty or could not be parsed into records.');
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    message: 'CSV file is empty or yielded no records.'
                }, {
                    status: 400
                });
            }
            connection = await pool.getConnection();
            console.log('[API_INFO] /api/tags POST CSV: Database connection obtained for batch insert/update.');
            await connection.beginTransaction();
            console.log('[API_INFO] /api/tags POST CSV: Started database transaction.');
            let successfulImports = 0;
            let failedImports = 0;
            const importErrors = [];
            for (const [index, record] of results.entries()){
                // Consistent header access (all lowercase due to mapHeaders)
                const tagId = record.id || record.tagid || (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])(); // Use provided ID or generate new one
                const tagNumber = record.tagnumber || record['tag number'];
                if (!tagNumber) {
                    failedImports++;
                    const errorMsg = `Skipped record #${index + 1} (ID: ${tagId}): Tag Number is required. Record data: ${JSON.stringify(record)}`;
                    console.warn(`[API_WARN] /api/tags POST CSV: ${errorMsg}`);
                    importErrors.push(errorMsg);
                    continue;
                }
                const registration = record.registration || null;
                const make = record.make || null;
                const model = record.model || null;
                const tankCapacity = record.tankcapacity || record['tank capacity'] ? parseInt(record.tankcapacity || record['tank capacity'], 10) : null;
                const year = record.year ? parseInt(record.year, 10) : null;
                const chassisNo = record.chassisno || record['chassis no.'] || null;
                const type = record.type || null;
                const siteId = record.siteid || record['site id'] ? parseInt(record.siteid || record['site id'], 10) : null;
                let status = record.status || 'Active';
                if (!tagStatuses.includes(status)) {
                    console.warn(`[API_WARN] /api/tags POST CSV: Invalid status "${status}" for Tag ID ${tagId}. Defaulting to 'Active'.`);
                    status = 'Active';
                }
                console.log(`[API_DEBUG] /api/tags POST CSV: Processing record #${index + 1}: ID=${tagId}, TagNumber=${tagNumber}, Status=${status}`);
                try {
                    const query = `
            INSERT INTO Tag (id, tagNumber, registration, make, model, tankCapacity, year, chassisNo, type, status, siteId, createdAt, updatedAt)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
            ON DUPLICATE KEY UPDATE
              tagNumber = VALUES(tagNumber), registration = VALUES(registration), make = VALUES(make), model = VALUES(model),
              tankCapacity = VALUES(tankCapacity), year = VALUES(year), chassisNo = VALUES(chassisNo), type = VALUES(type),
              status = VALUES(status), siteId = VALUES(siteId), updatedAt = NOW();
          `;
                    await connection.execute(query, [
                        tagId,
                        tagNumber,
                        registration,
                        make,
                        model,
                        isNaN(tankCapacity) ? null : tankCapacity,
                        isNaN(year) ? null : year,
                        chassisNo,
                        type,
                        status,
                        isNaN(siteId) ? null : siteId
                    ]);
                    successfulImports++;
                } catch (dbError) {
                    failedImports++;
                    const errorMsg = `Failed to process record #${index + 1} (ID ${tagId}, TagNumber: ${tagNumber}): ${dbError.message}. SQL Error Code: ${dbError.code || 'N/A'}.`;
                    console.error(`[API_ERROR] /api/tags POST CSV: Database error for record: ${errorMsg}`, dbError);
                    importErrors.push(errorMsg);
                }
            }
            await connection.commit();
            console.log('[API_INFO] /api/tags POST CSV: Database transaction committed.');
            let message = `${successfulImports} tag(s) processed successfully from CSV.`;
            if (failedImports > 0) {
                message += ` ${failedImports} tag(s) failed.`;
            }
            console.log(`[API_INFO] /api/tags POST CSV: Final processing result - ${message}`);
            if (importErrors.length > 0) {
                console.warn('[API_WARN] /api/tags POST CSV: Errors encountered during processing:', importErrors);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message,
                processed: successfulImports,
                failed: failedImports,
                errors: importErrors.length > 0 ? importErrors : undefined
            }, {
                status: importErrors.length > 0 && successfulImports === 0 ? 400 : 200
            });
        } catch (error) {
            if (connection) {
                try {
                    await connection.rollback();
                    console.log('[API_INFO] /api/tags POST CSV: Database transaction rolled back due to error.');
                } catch (rbError) {
                    console.error('[API_ERROR] /api/tags POST CSV: Error during transaction rollback:', rbError);
                }
            }
            console.error('[API_ERROR] /api/tags POST CSV (outer try-catch):', error);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to handle tag CSV upload.',
                details: error.message
            }, {
                status: 500
            });
        } finally{
            if (connection) {
                try {
                    connection.release();
                    console.log('[API_INFO] /api/tags POST CSV: Database connection released.');
                } catch (relError) {
                    console.error('[API_ERROR] /api/tags POST CSV: Error releasing connection:', relError);
                }
            }
        }
    } else if (contentType && contentType.includes('application/json')) {
        console.log('[API_INFO] /api/tags POST: Received application/json request.');
        try {
            const tagData = await request.json();
            if (!tagData.id || !tagData.tagNumber) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Tag ID and Tag Number are required.'
                }, {
                    status: 400
                });
            }
            let status = tagData.status || 'Active';
            if (!tagStatuses.includes(status)) {
                console.warn(`[API_WARN] /api/tags POST JSON: Invalid status "${status}" for Tag ID ${tagData.id}. Defaulting to 'Active'.`);
                status = 'Active';
            }
            const query = `
        INSERT INTO Tag (id, tagNumber, registration, make, model, tankCapacity, year, chassisNo, type, siteId, status, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `;
            await pool.execute(query, [
                tagData.id,
                tagData.tagNumber,
                tagData.registration || null,
                tagData.make || null,
                tagData.model || null,
                tagData.tankCapacity ? Number(tagData.tankCapacity) : null,
                tagData.year ? Number(tagData.year) : null,
                tagData.chassisNo || null,
                tagData.type || null,
                tagData.siteId ? Number(tagData.siteId) : null,
                status
            ]);
            const [newTagRows] = await pool.execute('SELECT t.*, s.siteCode as siteName FROM Tag t LEFT JOIN Site s ON t.siteId = s.id WHERE t.id = ?', [
                tagData.id
            ]);
            if (newTagRows.length === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Tag created but failed to retrieve.'
                }, {
                    status: 500
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(newTagRows[0], {
                status: 201
            });
        } catch (error) {
            console.error('[API_ERROR] /api/tags POST JSON: Error creating tag:', error);
            if (error.code === 'ER_DUP_ENTRY') {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Tag with this ID or Tag Number already exists.'
                }, {
                    status: 409
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to create tag (JSON)',
                details: error.message
            }, {
                status: 500
            });
        }
    } else {
        console.warn(`[API_WARN] /api/tags POST: Unsupported Content-Type: ${contentType}`);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unsupported Content-Type'
        }, {
            status: 415
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__69d769c3._.js.map