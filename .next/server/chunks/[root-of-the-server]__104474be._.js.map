{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/api/auth/me/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { cookies } from 'next/headers';\n\nconst SESSION_COOKIE_NAME = 'procuretrack-session-cookie';\n\nexport async function GET(request: Request) {\n  const sessionCookie = cookies().get(SESSION_COOKIE_NAME);\n\n  if (!sessionCookie || !sessionCookie.value) {\n    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });\n  }\n\n  try {\n    // In a real app with JWTs, you would verify the token here.\n    // For this prototype, we parse the user data stored directly in the cookie.\n    const userData = JSON.parse(sessionCookie.value);\n    \n    // You might want to re-validate against the DB here in a real app,\n    // but for session restoration, this is often sufficient.\n    return NextResponse.json(userData);\n  } catch (error) {\n    console.error('Error parsing session cookie:', error);\n    // If cookie is malformed, treat as unauthenticated\n    return NextResponse.json({ error: 'Invalid session' }, { status: 401 });\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEA,MAAM,sBAAsB;AAErB,eAAe,IAAI,OAAgB;IACxC,MAAM,gBAAgB,CAAA,GAAA,iIAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC;IAEpC,IAAI,CAAC,iBAAiB,CAAC,cAAc,KAAK,EAAE;QAC1C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAoB,GAAG;YAAE,QAAQ;QAAI;IACzE;IAEA,IAAI;QACF,4DAA4D;QAC5D,4EAA4E;QAC5E,MAAM,WAAW,KAAK,KAAK,CAAC,cAAc,KAAK;QAE/C,mEAAmE;QACnE,yDAAyD;QACzD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,mDAAmD;QACnD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAkB,GAAG;YAAE,QAAQ;QAAI;IACvE;AACF","debugId":null}}]
}