module.exports = {

"[project]/.next-internal/server/app/api/clients/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@opentelemetry/api", () => require("@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/timers [external] (timers, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/string_decoder [external] (string_decoder, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[project]/backend/db.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "pool": (()=>pool)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/promise.js [app-route] (ecmascript)");
;
// Check for essential DB environment variables
const essentialEnvVars = [
    'DB_HOST',
    'DB_USER',
    'DB_PASSWORD',
    'DB_NAME'
];
const missingEnvVars = essentialEnvVars.filter((v)=>!process.env[v]);
if (missingEnvVars.length > 0) {
    const errorMessage = `CRITICAL_DB_INIT_ERROR: Missing essential database environment variables: ${missingEnvVars.join(', ')}. Please define these in your root .env file. Database connections will fail until this is resolved.`;
    console.error(errorMessage);
    throw new Error(errorMessage);
}
// The CA certificate content is now expected to be in an environment variable.
const caCert = process.env.DB_SSL_CA;
if (!caCert) {
    console.warn(`DB_WARN: The DB_SSL_CA environment variable is not set. Database connections may fail if SSL is required by your provider. For local development without SSL, this may be ignored.`);
}
let pool;
try {
    pool = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool({
        host: process.env.DB_HOST,
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        port: process.env.DB_PORT ? parseInt(process.env.DB_PORT, 10) : 3306,
        // Conditionally add SSL options only if the certificate is provided.
        ...caCert && {
            ssl: {
                ca: caCert,
                rejectUnauthorized: true
            }
        },
        waitForConnections: true,
        connectionLimit: 10,
        queueLimit: 0
    });
    console.log("DB_INIT_SUCCESS: MySQL connection pool created (this does not guarantee successful connection yet, but configuration is loaded).");
} catch (error) {
    console.error(`CRITICAL_DB_INIT_ERROR: Failed to create MySQL connection pool: ${error.message}. This is a fatal error for database operations.`);
    throw new Error(`Failed to initialize database connection pool due to: ${error.message}. Review DB environment variables.`);
}
;
}}),
"[project]/src/app/api/clients/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET),
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/backend/db.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$parser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/csv-parser/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
;
;
;
;
async function GET() {
    console.log('[API_INFO] /api/clients GET: Received request to fetch clients.');
    try {
        const [rows] = await __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pool"].execute('SELECT id, name, address, city, country, contactPerson, email, createdAt, updatedAt FROM Client ORDER BY name ASC');
        console.log(`[API_INFO] /api/clients GET: Successfully fetched ${Array.isArray(rows) ? rows.length : 0} clients from DB.`);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(rows);
    } catch (error) {
        console.error('[API_ERROR] /api/clients GET: Error fetching clients from DB:', error);
        // Log more detailed error information if available
        console.error('[API_ERROR_DETAILS] /api/clients GET: Error message:', error.message);
        console.error('[API_ERROR_DETAILS] /api/clients GET: Error name:', error.name);
        console.error('[API_ERROR_DETAILS] /api/clients GET: Error code (if DB error):', error.code);
        console.error('[API_ERROR_DETAILS] /api/clients GET: Error stack:', error.stack);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to fetch clients from database. Please check server logs for more details.',
            details: ("TURBOPACK compile-time truthy", 1) ? error.message : ("TURBOPACK unreachable", undefined)
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    const contentType = request.headers.get('content-type');
    if (contentType && contentType.includes('multipart/form-data')) {
        console.log('[API_INFO] /api/clients POST: Received multipart/form-data request for CSV upload.');
        try {
            const formData = await request.formData();
            const file = formData.get('file');
            if (!file) {
                console.error('[API_ERROR] /api/clients POST CSV: No file found in formData.');
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'No file uploaded'
                }, {
                    status: 400
                });
            }
            console.log(`[API_INFO] /api/clients POST CSV: Received file: ${file.name}, size: ${file.size}, type: ${file.type}`);
            const fileBuffer = Buffer.from(await file.arrayBuffer());
            const results = [];
            const stream = __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"].from(fileBuffer);
            let firstRecordLogged = false;
            console.log('[API_INFO] /api/clients POST CSV: Starting CSV parsing...');
            await new Promise((resolve, reject)=>{
                stream.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$csv$2d$parser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                    mapHeaders: ({ header, index })=>{
                        const trimmedHeader = header.trim();
                        console.log(`[API_DEBUG] /api/clients POST CSV: Mapped CSV header at index ${index}: '${header}' to '${trimmedHeader}'`);
                        return trimmedHeader;
                    }
                })).on('headers', (headers)=>{
                    console.log('[API_INFO] /api/clients POST CSV: Detected CSV Headers:', headers);
                }).on('data', (data)=>{
                    if (!firstRecordLogged) {
                        console.log('[API_DEBUG] /api/clients POST CSV: First parsed data record from CSV:', data);
                        firstRecordLogged = true;
                    }
                    results.push(data);
                }).on('end', ()=>{
                    console.log(`[API_INFO] /api/clients POST CSV: CSV parsing finished. ${results.length} records found.`);
                    resolve();
                }).on('error', (parseError)=>{
                    console.error('[API_ERROR] /api/clients POST CSV: Error during CSV parsing:', parseError);
                    reject(parseError);
                });
            });
            if (results.length === 0) {
                console.warn('[API_WARN] /api/clients POST CSV: CSV file is empty or could not be parsed into records.');
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    message: 'CSV file is empty or yielded no records.'
                }, {
                    status: 400
                });
            }
            let successfulInserts = 0;
            let failedInserts = 0;
            const errors = [];
            const connection = await __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pool"].getConnection();
            console.log('[API_INFO] /api/clients POST CSV: Database connection obtained for batch insert/update.');
            try {
                await connection.beginTransaction();
                console.log('[API_INFO] /api/clients POST CSV: Started database transaction.');
                for (const [index, record] of results.entries()){
                    // Consistent header access, case-insensitive for common variations
                    const clientId = record.ID || record.id || record.Id || (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])();
                    const clientName = record.Name || record.name;
                    const clientAddress = record.Address || record.address || null;
                    const clientCity = record.City || record.city || null;
                    const clientCountry = record.Country || record.country || null;
                    const clientContactPerson = record['Contact Person'] || record.contactPerson || record.Contact || null;
                    const clientEmail = record['Contact Email'] || record.contactEmail || record.Email || null;
                    if (!clientName) {
                        failedInserts++;
                        const errorMsg = `Skipped record #${index + 1} (potential ID: ${clientId}): Name is required. Record data: ${JSON.stringify(record)}`;
                        console.warn(`[API_WARN] /api/clients POST CSV: ${errorMsg}`);
                        errors.push(errorMsg);
                        continue;
                    }
                    console.log(`[API_DEBUG] /api/clients POST CSV: Processing record #${index + 1}: ID=${clientId}, Name=${clientName}, Address=${clientAddress}, City=${clientCity}, Country=${clientCountry}, ContactPerson=${clientContactPerson}, Email=${clientEmail}`);
                    try {
                        const query = `
              INSERT INTO Client (id, name, address, city, country, contactPerson, email, createdAt, updatedAt)
              VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
              ON DUPLICATE KEY UPDATE 
                name = VALUES(name), 
                address = VALUES(address), 
                city = VALUES(city), 
                country = VALUES(country), 
                contactPerson = VALUES(contactPerson), 
                email = VALUES(email), 
                updatedAt = NOW();
            `;
                        await connection.execute(query, [
                            clientId,
                            clientName,
                            clientAddress,
                            clientCity,
                            clientCountry,
                            clientContactPerson,
                            clientEmail
                        ]);
                        successfulInserts++;
                        console.log(`[API_INFO] /api/clients POST CSV: Successfully processed client ID: ${clientId}`);
                    } catch (dbError) {
                        failedInserts++;
                        const errorMsg = `Failed to insert/update record #${index + 1} (ID ${clientId}, Name: ${clientName || 'N/A'}): ${dbError.message}. SQL Error Code: ${dbError.code || 'N/A'}.`;
                        console.error(`[API_ERROR] /api/clients POST CSV: Database error for record: ${errorMsg}`, dbError);
                        errors.push(errorMsg);
                    }
                }
                await connection.commit();
                console.log('[API_INFO] /api/clients POST CSV: Database transaction committed.');
            } catch (transactionError) {
                await connection.rollback();
                console.error('[API_ERROR] /api/clients POST CSV: Transaction error during client import:', transactionError);
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Transaction failed during CSV import.',
                    details: transactionError.message,
                    errors
                }, {
                    status: 500
                });
            } finally{
                connection.release();
                console.log('[API_INFO] /api/clients POST CSV: Database connection released.');
            }
            let message = `${successfulInserts} client(s) processed successfully.`;
            if (failedInserts > 0) {
                message += ` ${failedInserts} client(s) failed.`;
            }
            console.log(`[API_INFO] /api/clients POST CSV: Final processing result - ${message}`);
            if (errors.length > 0) {
                console.warn('[API_WARN] /api/clients POST CSV: Errors encountered during processing:', errors);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                message,
                errors: errors.length > 0 ? errors : undefined
            }, {
                status: errors.length > 0 && successfulInserts === 0 ? 400 : 200
            });
        } catch (error) {
            console.error('[API_ERROR] /api/clients POST CSV: Error handling client CSV upload (outer try-catch):', error);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to handle client CSV upload.',
                details: error.message
            }, {
                status: 500
            });
        }
    } else if (contentType && contentType.includes('application/json')) {
        console.log('[API_INFO] /api/clients POST: Received application/json request.');
        try {
            const clientData = await request.json();
            if (!clientData.id || !clientData.name) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Client ID and Name are required.'
                }, {
                    status: 400
                });
            }
            const query = `
        INSERT INTO Client (id, name, address, city, country, contactPerson, email, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
      `;
            await __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pool"].execute(query, [
                clientData.id,
                clientData.name,
                clientData.address || null,
                clientData.city || null,
                clientData.country || null,
                clientData.contactPerson || null,
                clientData.email || null
            ]);
            const [newClientRows] = await __TURBOPACK__imported__module__$5b$project$5d2f$backend$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["pool"].execute('SELECT id, name, address, city, country, contactPerson, email, createdAt, updatedAt FROM Client WHERE id = ?', [
                clientData.id
            ]);
            if (newClientRows.length === 0) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Client created but failed to retrieve.'
                }, {
                    status: 500
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(newClientRows[0], {
                status: 201
            });
        } catch (error) {
            console.error('[API_ERROR] /api/clients POST JSON: Error creating client:', error);
            if (error.code === 'ER_DUP_ENTRY') {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    error: 'Client with this ID already exists.'
                }, {
                    status: 409
                });
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Failed to create client (JSON)',
                details: error.message
            }, {
                status: 500
            });
        }
    } else {
        console.warn(`[API_WARN] /api/clients POST: Unsupported Content-Type: ${contentType}`);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Unsupported Content-Type'
        }, {
            status: 415
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__bc9dda8b._.js.map