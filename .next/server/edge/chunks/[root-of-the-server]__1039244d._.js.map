{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/firebase/server.ts"],"sourcesContent":["// This file is for SERVER-SIDE use only.\n// It initializes the Firebase Admin SDK.\n\nimport { initializeApp, getApp, getApps, type App, cert } from 'firebase-admin/app';\nimport { getAuth as getAdminAuth } from 'firebase-admin/auth';\nimport { getFirestore as getAdminFirestore } from 'firebase-admin/firestore';\n\nconst serviceAccount = {\n  projectId: process.env.FIREBASE_PROJECT_ID,\n  clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n  privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\\\n/g, '\\n'), // Important for Vercel/env variables\n};\n\nfunction getAdminApp(): App {\n  // Check if the default app is already initialized\n  if (getApps().some(app => app.name === '[DEFAULT]')) {\n    return getApp();\n  }\n\n  // Check for credentials before initializing to provide a clearer error\n  if (!serviceAccount.projectId || !serviceAccount.clientEmail || !serviceAccount.privateKey) {\n    throw new Error('Firebase Admin credentials are not set in the environment. Please check your .env.local file.');\n  }\n\n  return initializeApp({\n    credential: cert(serviceAccount),\n  });\n}\n\n// Directly export functions that return the initialized services\nexport const getAuth = () => getAdminAuth(getAdminApp());\nexport const getFirestore = () => getAdminFirestore(getAdminApp());\n"],"names":[],"mappings":"AAAA,yCAAyC;AACzC,yCAAyC;;;;;AAEzC;AACA;AACA;;;;AAEA,MAAM,iBAAiB;IACrB,WAAW,QAAQ,GAAG,CAAC,mBAAmB;IAC1C,aAAa,QAAQ,GAAG,CAAC,qBAAqB;IAC9C,YAAY,QAAQ,GAAG,CAAC,oBAAoB,EAAE,QAAQ,QAAQ;AAChE;AAEA,SAAS;IACP,kDAAkD;IAClD,IAAI,CAAA,GAAA,uKAAA,CAAA,UAAO,AAAD,IAAI,IAAI,CAAC,CAAA,MAAO,IAAI,IAAI,KAAK,cAAc;QACnD,OAAO,CAAA,GAAA,uKAAA,CAAA,SAAM,AAAD;IACd;IAEA,uEAAuE;IACvE,IAAI,CAAC,eAAe,SAAS,IAAI,CAAC,eAAe,WAAW,IAAI,CAAC,eAAe,UAAU,EAAE;QAC1F,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,CAAA,GAAA,uKAAA,CAAA,gBAAa,AAAD,EAAE;QACnB,YAAY,CAAA,GAAA,uKAAA,CAAA,OAAI,AAAD,EAAE;IACnB;AACF;AAGO,MAAM,UAAU,IAAM,CAAA,GAAA,wKAAA,CAAA,UAAY,AAAD,EAAE;AACnC,MAAM,eAAe,IAAM,CAAA,GAAA,6KAAA,CAAA,eAAiB,AAAD,EAAE"}},
    {"offset": {"line": 85, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["\nimport { NextResponse, type NextRequest } from 'next/server';\nimport { cookies } from 'next/headers';\nimport { getAuth } from '@/lib/firebase/server';\n\nconst PROTECTED_ROUTES = ['/', '/create-document', '/approvals', '/activity-log', '/analytics', '/reports', '/management'];\nconst AUTH_ROUTE = '/auth';\n\nexport async function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n\n  // Skip middleware for static files, API routes, and Next.js internals\n  if (\n    pathname.startsWith('/_next/') ||\n    pathname.startsWith('/api/') ||\n    pathname.startsWith('/static/') ||\n    ['/favicon.ico', '/jachris-logo.png', '/headerlogo.png'].includes(pathname)\n  ) {\n    return NextResponse.next();\n  }\n\n  const sessionCookie = cookies().get(process.env.SESSION_COOKIE_NAME!)?.value;\n\n  // Redirect to auth page if trying to access a protected route without a session\n  if (!sessionCookie && PROTECTED_ROUTES.some(p => pathname.startsWith(p))) {\n    const url = request.nextUrl.clone();\n    url.pathname = AUTH_ROUTE;\n    return NextResponse.redirect(url);\n  }\n\n  try {\n    if (sessionCookie) {\n      // 1. Verify the Firebase session cookie. If invalid, it will throw an error.\n      // Database checks for user status are incompatible with the Edge Runtime and have been removed.\n      // This type of authorization should be handled in API routes or Server Components.\n      await getAuth().verifySessionCookie(sessionCookie, true);\n      \n      // If authenticated user tries to access the auth page, redirect to home\n      if (pathname === AUTH_ROUTE) {\n        return NextResponse.redirect(new URL('/', request.url));\n      }\n    }\n  } catch (error: any) {\n    // Catches errors from verifySessionCookie.\n    console.error('Middleware auth error:', error.message);\n    // Session cookie is invalid or user not authorized. Clear it and redirect to auth page.\n    const response = NextResponse.redirect(new URL(AUTH_ROUTE, request.url));\n    response.cookies.set(process.env.SESSION_COOKIE_NAME!, '', { maxAge: -1 });\n    return response;\n  }\n\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    '/((?!api|_next/static|_next/image|favicon.ico).*)',\n  ],\n};\n"],"names":[],"mappings":";;;;AACA;AAAA;AACA;AAAA;AACA;;;;AAEA,MAAM,mBAAmB;IAAC;IAAK;IAAoB;IAAc;IAAiB;IAAc;IAAY;CAAc;AAC1H,MAAM,aAAa;AAEZ,eAAe,WAAW,OAAoB;IACnD,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IAEpC,sEAAsE;IACtE,IACE,SAAS,UAAU,CAAC,cACpB,SAAS,UAAU,CAAC,YACpB,SAAS,UAAU,CAAC,eACpB;QAAC;QAAgB;QAAqB;KAAkB,CAAC,QAAQ,CAAC,WAClE;QACA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC1B;IAEA,MAAM,gBAAgB,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,IAAI,GAAG,CAAC,QAAQ,GAAG,CAAC,mBAAmB,GAAI;IAEvE,gFAAgF;IAChF,IAAI,CAAC,iBAAiB,iBAAiB,IAAI,CAAC,CAAA,IAAK,SAAS,UAAU,CAAC,KAAK;QACxE,MAAM,MAAM,QAAQ,OAAO,CAAC,KAAK;QACjC,IAAI,QAAQ,GAAG;QACf,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,IAAI;QACF,IAAI,eAAe;YACjB,6EAA6E;YAC7E,gGAAgG;YAChG,mFAAmF;YACnF,MAAM,CAAA,GAAA,wIAAA,CAAA,UAAO,AAAD,IAAI,mBAAmB,CAAC,eAAe;YAEnD,wEAAwE;YACxE,IAAI,aAAa,YAAY;gBAC3B,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;YACvD;QACF;IACF,EAAE,OAAO,OAAY;QACnB,2CAA2C;QAC3C,QAAQ,KAAK,CAAC,0BAA0B,MAAM,OAAO;QACrD,wFAAwF;QACxF,MAAM,WAAW,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,QAAQ,GAAG;QACtE,SAAS,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAC,mBAAmB,EAAG,IAAI;YAAE,QAAQ,CAAC;QAAE;QACxE,OAAO;IACT;IAEA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QACP;;;;;;KAMC,GACD;KACD;AACH"}}]
}